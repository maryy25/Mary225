<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Pink Heart Animation</title>

    <!-- Import map for three.js modules -->
    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.162.0/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.162.0/examples/jsm/"
        }
      }
    </script>

    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        overflow: hidden;
        background-color: #000;
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        color: #fff;
        /* خلفية وردية داكنة متدرجة */
        background: linear-gradient(180deg, #000000 0%, #1f000f 50%, #2e0017 100%);
      }

      #container {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        overflow: hidden;
      }

      /* تنسيق الاسم باللون الوردي */
      #text-overlay {
        position: fixed;
        top: 65%;
        left: 50%;
        transform: translate(-50%, -50%);
        font-family: 'Brush Script MT', 'Dancing Script', 'Segoe Script', cursive;
        font-size: 5rem;
        color: #ffcae9; /* وردي فاتح جداً للنص */
        pointer-events: none;
        z-index: 50;
        opacity: 0;
        animation: fadeIn 4s ease-out forwards;
        letter-spacing: 2px;
        /* توهج وردي */
        text-shadow: 
          0 0 10px #fff,
          0 0 20px #ff69b4, /* Hot Pink */
          0 0 40px #ff1493, /* Deep Pink */
          0 0 80px #c71585; /* Medium Violet Red */
      }

      @keyframes fadeIn {
        0% { opacity: 0; transform: translate(-50%, -40%); }
        100% { opacity: 1; transform: translate(-50%, -50%); }
      }

      /* Glow overlay - Pink */
      .glow {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        mix-blend-mode: screen;
        opacity: 0.6;
        background: radial-gradient(
          circle at 50% 50%,
          rgba(255, 20, 147, 0.08) 0%, 
          rgba(199, 21, 133, 0.05) 50%, 
          transparent 65%
        );
      }

      /* Controls Styling - Pink Theme */
      #controls {
        position: fixed;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        display: flex;
        flex-direction: row;
        align-items: center;
        gap: 20px;
        z-index: 100;
        border: 1px solid rgba(255, 105, 180, 0.4);
        background: rgba(60, 20, 40, 0.3);
        border-radius: 16px;
        padding: 10px 20px;
        backdrop-filter: blur(12px);
        -webkit-backdrop-filter: blur(12px);
        box-shadow: 0 4px 30px rgba(0, 0, 0, 0.2);
      }

      .toggle-option {
        display: flex;
        align-items: center;
        gap: 10px;
      }

      .toggle-option label[for='animateToggle'] {
        cursor: pointer;
        font-size: 13px;
        font-weight: 300;
        color: rgba(255, 200, 220, 0.9);
      }

      .toggle-switch {
        position: relative;
        display: inline-block;
        width: 46px;
        height: 24px;
      }
      .toggle-switch input {
        opacity: 0;
        width: 0;
        height: 0;
      }
      .toggle-slider {
        position: absolute;
        cursor: pointer;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        transition: 0.3s;
        border-radius: 24px;
        background: rgba(255, 20, 147, 0.4);
      }
      .toggle-slider:before {
        position: absolute;
        content: '';
        height: 18px;
        width: 18px;
        left: 3px;
        bottom: 3px;
        background-color: white;
        transition: 0.3s;
        border-radius: 50%;
        box-shadow: 0 0 8px rgba(255, 105, 180, 0.8);
      }
      input:checked + .toggle-slider {
        background-color: rgba(255, 20, 147, 0.6);
      }
      input:checked + .toggle-slider:before {
        transform: translateX(22px);
      }

      @media (max-width: 768px) {
        #text-overlay {
            font-size: 3rem;
            top: 60%;
        }
      }
    </style>
  </head>

  <body>
    <div id="container"></div>
    <div class="glow"></div>
    
    <!-- الاسم باللون الوردي -->
    <div id="text-overlay">Mary</div>
    
    <div id="controls"></div>

    <script type="module">
      import * as THREE from 'three';
      import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
      import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
      import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
      import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';
      import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

      let scene, camera, renderer, particles, composer, controls;
      let time = 0;
      let isAnimationEnabled = true;
      let currentTheme = 'pink';
      
      // Fixed: Always Heart
      let morphTarget = 1; 
      let morphProgress = 1;

      const particleCount = 10000;

      // Single Pink Theme
      const themes = {
        pink: {
          name: 'Pink',
          colors: [
            new THREE.Color(0xff0080), // Deep Pink
            new THREE.Color(0xff66b2), // Light Pink
            new THREE.Color(0xff1493), // Deep Pink
            new THREE.Color(0xffb6c1), // Light Pink
            new THREE.Color(0xc71585)  // Medium Violet Red
          ],
          bloom: { strength: 0.45, radius: 0.5, threshold: 0.6 }
        }
      };

      document.addEventListener('DOMContentLoaded', init);

      function createStarPath(particleIndex, totalParticles) {
        // Unused placeholder
        return new THREE.Vector3(0,0,0);
      }

      function createHeartPath(particleIndex, totalParticles) {
        const t = (particleIndex / totalParticles) * Math.PI * 2;
        const scale = 2.2;

        let x = 16 * Math.pow(Math.sin(t), 3);
        let y = 13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 *
        Math.cos(3 * t) - Math.cos(4 * t);

        const finalX = x * scale;
        const finalY = y * scale;
        const z = Math.sin(t * 4) * 2;

        const jitterStrength = 0.2;
        return new THREE.Vector3(
          finalX + (Math.random() - 0.5) * jitterStrength,
          finalY + (Math.random() - 0.5) * jitterStrength,
          z + (Math.random() - 0.5) * jitterStrength * 0.5
        );
      }

      function init() {
        scene = new THREE.Scene();

        camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1500);
        camera.position.z = 90;

        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.getElementById('container').appendChild(renderer.domElement);

        createUI();

        controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.04;
        controls.rotateSpeed = 0.3;
        controls.minDistance = 30;
        controls.maxDistance = 300;
        controls.enablePan = false;
        controls.autoRotate = false;
        controls.autoRotateSpeed = 0.15;

        composer = new EffectComposer(renderer);
        composer.addPass(new RenderPass(scene, camera));
        
        // Bloom for Pink Glow
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        composer.addPass(bloomPass);
        composer.addPass(new OutputPass());
        scene.userData.bloomPass = bloomPass;

        createParticleSystem();

        window.addEventListener('resize', onWindowResize);

        setTheme('pink');
        animate();
      }

      function createUI() {
        const controlsDiv = document.getElementById('controls');
        controlsDiv.innerHTML = '';
        
        // Removed Theme Buttons (Fixed Pink)

        const toggleOption = document.createElement('div');
        toggleOption.className = 'toggle-option';

        const toggleLabel = document.createElement('label');
        toggleLabel.className = 'toggle-switch';

        const toggleInput = document.createElement('input');
        toggleInput.type = 'checkbox';
        toggleInput.id = 'animateToggle';
        toggleInput.checked = true;
        toggleInput.addEventListener('change', (e) => {
          isAnimationEnabled = e.target.checked;
        });

        const toggleSlider = document.createElement('span');
        toggleSlider.className = 'toggle-slider';

        toggleLabel.appendChild(toggleInput);
        toggleLabel.appendChild(toggleSlider);

        const labelForToggle = document.createElement('label');
        labelForToggle.htmlFor = 'animateToggle';
        labelForToggle.textContent = 'Animate';

        toggleOption.appendChild(toggleLabel);
        toggleOption.appendChild(labelForToggle);
        controlsDiv.appendChild(toggleOption);
      }

      function createParticleSystem() {
        const geometry = new THREE.BufferGeometry();

        const positions = new Float32Array(particleCount * 3);
        const colors = new Float32Array(particleCount * 3);
        const sizes = new Float32Array(particleCount);

        const heartPositions = new Float32Array(particleCount * 3);
        const disintegrationOffsets = new Float32Array(particleCount * 3);

        for (let i = 0; i < particleCount; i++) {
          const i3 = i * 3;

          const heartPos = createHeartPath(i, particleCount);

          // Initial positions set to Heart directly
          positions[i3] = heartPos.x;
          positions[i3 + 1] = heartPos.y;
          positions[i3 + 2] = heartPos.z;

          heartPositions[i3] = heartPos.x;
          heartPositions[i3 + 1] = heartPos.y;
          heartPositions[i3 + 2] = heartPos.z;

          const { color, size } = getAttributesForParticle(i);
          colors[i3] = color.r;
          colors[i3 + 1] = color.g;
          colors[i3 + 2] = color.b;
          sizes[i] = size;

          const offsetStrength = 30 + Math.random() * 40;
          const phi = Math.random() * Math.PI * 2;
          const theta = Math.acos(2 * Math.random() - 1);

          disintegrationOffsets[i3] = Math.sin(theta) * Math.cos(phi) * offsetStrength;
          disintegrationOffsets[i3 + 1] = Math.sin(theta) * Math.sin(phi) * offsetStrength;
          disintegrationOffsets[i3 + 2] = Math.cos(theta) * offsetStrength * 0.5;
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
        geometry.setAttribute('heartPosition', new THREE.BufferAttribute(heartPositions, 3));
        geometry.setAttribute('disintegrationOffset', new THREE.BufferAttribute(disintegrationOffsets, 3));

        const texture = createParticleTexture();
        const material = new THREE.PointsMaterial({
          size: 2.8,
          map: texture,
          vertexColors: true,
          transparent: true,
          blending: THREE.AdditiveBlending,
          depthWrite: false,
          sizeAttenuation: true,
          alphaTest: 0.01
        });

        particles = new THREE.Points(geometry, material);
        scene.add(particles);
      }

      function getAttributesForParticle(i) {
        const t = i / particleCount;
        const colorPalette = themes[currentTheme].colors;

        const colorProgress = (t * colorPalette.length * 1.5 + time * 0.05) % colorPalette.length;
        const colorIndex1 = Math.floor(colorProgress);
        const colorIndex2 = (colorIndex1 + 1) % colorPalette.length;
        const blendFactor = colorProgress - colorIndex1;

        const color1 = colorPalette[colorIndex1];
        const color2 = colorPalette[colorIndex2];
        const baseColor = new THREE.Color().lerpColors(color1, color2, blendFactor);

        const color = baseColor.clone().multiplyScalar(0.65 + Math.random() * 0.55);
        const size = 0.65 + Math.random() * 0.6;

        return { color, size };
      }

      function createParticleTexture() {
        const canvas = document.createElement('canvas');
        const size = 64;
        canvas.width = size;
        canvas.height = size;
        const context = canvas.getContext('2d');

        const centerX = size / 2;
        const centerY = size / 2;
        const outerRadius = size * 0.45;
        const innerRadius = size * 0.2;
        const numPoints = 5;

        context.beginPath();
        context.moveTo(centerX, centerY - outerRadius);
        for (let i = 0; i < numPoints; i++) {
          const outerAngle = (i / numPoints) * Math.PI * 2 - Math.PI / 2;
          context.lineTo(centerX + outerRadius * Math.cos(outerAngle), centerY + outerRadius * Math.sin(outerAngle));
          const innerAngle = outerAngle + Math.PI / numPoints;
          context.lineTo(centerX + innerRadius * Math.cos(innerAngle), centerY + innerRadius * Math.sin(innerAngle));
        }
        context.closePath();

        // Pink/Rose Gradient
        const gradient = context.createRadialGradient(centerX, centerY, 0, centerX, centerY, outerRadius);
        gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
        gradient.addColorStop(0.3, 'rgba(255, 192, 203, 0.9)'); // Pink
        gradient.addColorStop(0.6, 'rgba(255, 20, 147, 0.6)');  // Deep Pink
        gradient.addColorStop(1, 'rgba(255, 20, 147, 0)');

        context.fillStyle = gradient;
        context.fill();

        const texture = new THREE.CanvasTexture(canvas);
        texture.needsUpdate = true;
        return texture;
      }

      function animateParticles() {
        if (!particles || !isAnimationEnabled) return;

        const positions = particles.geometry.attributes.position.array;
        const heartPositions = particles.geometry.attributes.heartPosition.array;
        const particleColors = particles.geometry.attributes.color.array;
        const particleSizes = particles.geometry.attributes.size.array;
        const disintegrationOffsets = particles.geometry.attributes.disintegrationOffset.array;

        // Ensure always Heart shape
        morphProgress = 1;

        for (let i = 0; i < particleCount; i++) {
          const i3 = i * 3;
          const iSize = i;

          const homeX = heartPositions[i3];
          const homeY = heartPositions[i3 + 1];
          const homeZ = heartPositions[i3 + 2];

          const disintegrationCycleTime = 20.0;
          const particleCycleOffset = (i / particleCount) * disintegrationCycleTime * 0.5;
          const cycleProgress = ((time * 0.6 + particleCycleOffset) % disintegrationCycleTime) / disintegrationCycleTime;

          let disintegrationAmount = 0;
          const stablePhaseEnd = 0.5;
          const disintegrateStartPhase = stablePhaseEnd;
          const disintegrateFullPhase = stablePhaseEnd + 0.15;
          const holdPhaseEnd = disintegrateFullPhase + 0.1;

          if (cycleProgress < stablePhaseEnd) {
            disintegrationAmount = 0;
          } else if (cycleProgress < disintegrateFullPhase) {
            disintegrationAmount = (cycleProgress - disintegrateStartPhase) / (disintegrateFullPhase - disintegrateStartPhase);
          } else if (cycleProgress < holdPhaseEnd) {
            disintegrationAmount = 1.0;
          } else {
            disintegrationAmount = 1.0 - (cycleProgress - holdPhaseEnd) / (1.0 - holdPhaseEnd);
          }

          disintegrationAmount = Math.sin(disintegrationAmount * Math.PI * 0.5);

          let currentTargetX = homeX;
          let currentTargetY = homeY;
          let currentTargetZ = homeZ;
          let currentLerpFactor = 0.085;

          if (disintegrationAmount > 0.001) {
            currentTargetX = homeX + disintegrationOffsets[i3] * disintegrationAmount;
            currentTargetY = homeY + disintegrationOffsets[i3 + 1] * disintegrationAmount;
            currentTargetZ = homeZ + disintegrationOffsets[i3 + 2] * disintegrationAmount;
            currentLerpFactor = 0.045 + disintegrationAmount * 0.02;
          }

          positions[i3] += (currentTargetX - positions[i3]) * currentLerpFactor;
          positions[i3 + 1] += (currentTargetY - positions[i3 + 1]) * currentLerpFactor;
          positions[i3 + 2] += (currentTargetZ - positions[i3 + 2]) * currentLerpFactor;

          const { color: baseParticleColor, size: baseParticleSize } = getAttributesForParticle(i);

          let brightnessFactor =
            (0.65 + Math.sin((i / particleCount) * Math.PI * 7 + time * 1.3) * 0.35) * (1 - disintegrationAmount * 0.75);
          brightnessFactor *= 0.85 + Math.sin(time * 7 + i * 0.5) * 0.15;

          particleColors[i3] = baseParticleColor.r * brightnessFactor;
          particleColors[i3 + 1] = baseParticleColor.g * brightnessFactor;
          particleColors[i3 + 2] = baseParticleColor.b * brightnessFactor;

          let currentSize = baseParticleSize * (1 - disintegrationAmount * 0.9);
          currentSize *= 0.8 + Math.sin(time * 5 + i * 0.3) * 0.2;
          particleSizes[iSize] = Math.max(0.05, currentSize);
        }

        particles.geometry.attributes.position.needsUpdate = true;
        particles.geometry.attributes.color.needsUpdate = true;
        particles.geometry.attributes.size.needsUpdate = true;
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        composer.setSize(window.innerWidth, window.innerHeight);
      }

      function setTheme(themeName) {
        if (!themes[themeName]) return;
        currentTheme = themeName;
        
        const theme = themes[currentTheme];
        const bloomPass = scene.userData.bloomPass;
        if (bloomPass) {
          bloomPass.strength = theme.bloom.strength;
          bloomPass.radius = theme.bloom.radius;
          bloomPass.threshold = theme.bloom.threshold;
        }

        updateParticleColorsAndSizes();
      }

      function updateParticleColorsAndSizes() {
        if (!particles) return;

        const pColors = particles.geometry.attributes.color.array;
        const pSizes = particles.geometry.attributes.size.array;

        for (let i = 0; i < particleCount; i++) {
          const { color, size } = getAttributesForParticle(i);
          pColors[i * 3] = color.r;
          pColors[i * 3 + 1] = color.g;
          pColors[i * 3 + 2] = color.b;
          pSizes[i] = size;
        }

        particles.geometry.attributes.color.needsUpdate = true;
        particles.geometry.attributes.size.needsUpdate = true;
      }

      function animate() {
        requestAnimationFrame(animate);
        time += 0.02;
        controls.update();

        if (isAnimationEnabled) {
          animateParticles();
        }

        composer.render();
      }
    </script>
  </body>
</html>
